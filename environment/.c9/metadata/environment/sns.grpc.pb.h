{"changed":true,"filter":false,"title":"sns.grpc.pb.h","tooltip":"/sns.grpc.pb.h","value":"// Generated by the gRPC C++ plugin.\n// If you make any local change, they will be lost.\n// source: sns.proto\n#ifndef GRPC_sns_2eproto__INCLUDED\n#define GRPC_sns_2eproto__INCLUDED\n\n#include \"sns.pb.h\"\n\n#include <functional>\n#include <grpcpp/impl/codegen/async_generic_service.h>\n#include <grpcpp/impl/codegen/async_stream.h>\n#include <grpcpp/impl/codegen/async_unary_call.h>\n#include <grpcpp/impl/codegen/client_callback.h>\n#include <grpcpp/impl/codegen/client_context.h>\n#include <grpcpp/impl/codegen/completion_queue.h>\n#include <grpcpp/impl/codegen/message_allocator.h>\n#include <grpcpp/impl/codegen/method_handler.h>\n#include <grpcpp/impl/codegen/proto_utils.h>\n#include <grpcpp/impl/codegen/rpc_method.h>\n#include <grpcpp/impl/codegen/server_callback.h>\n#include <grpcpp/impl/codegen/server_callback_handlers.h>\n#include <grpcpp/impl/codegen/server_context.h>\n#include <grpcpp/impl/codegen/service_type.h>\n#include <grpcpp/impl/codegen/status.h>\n#include <grpcpp/impl/codegen/stub_options.h>\n#include <grpcpp/impl/codegen/sync_stream.h>\n\nnamespace csce438 {\n\n// ------------------------------------------------------------\n// The tiny service definition\n// These are the different functionalities exposed by service\n// ------------------------------------------------------------\nclass SNSService final {\n public:\n  static constexpr char const* service_full_name() {\n    return \"csce438.SNSService\";\n  }\n  class StubInterface {\n   public:\n    virtual ~StubInterface() {}\n    virtual ::grpc::Status Login(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) = 0;\n    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> AsyncLogin(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(AsyncLoginRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(PrepareAsyncLoginRaw(context, request, cq));\n    }\n    virtual ::grpc::Status List(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) = 0;\n    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> AsyncList(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(AsyncListRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> PrepareAsyncList(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(PrepareAsyncListRaw(context, request, cq));\n    }\n    virtual ::grpc::Status Follow(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) = 0;\n    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> AsyncFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(AsyncFollowRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> PrepareAsyncFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(PrepareAsyncFollowRaw(context, request, cq));\n    }\n    virtual ::grpc::Status UnFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) = 0;\n    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> AsyncUnFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(AsyncUnFollowRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>> PrepareAsyncUnFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>>(PrepareAsyncUnFollowRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::csce438::Message, ::csce438::Message>> Timeline(::grpc::ClientContext* context) {\n      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::csce438::Message, ::csce438::Message>>(TimelineRaw(context));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>> AsyncTimeline(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {\n      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>>(AsyncTimelineRaw(context, cq, tag));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>> PrepareAsyncTimeline(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>>(PrepareAsyncTimelineRaw(context, cq));\n    }\n    class async_interface {\n     public:\n      virtual ~async_interface() {}\n      virtual void Login(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) = 0;\n      virtual void Login(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;\n      virtual void List(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) = 0;\n      virtual void List(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;\n      virtual void Follow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) = 0;\n      virtual void Follow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;\n      virtual void UnFollow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) = 0;\n      virtual void UnFollow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;\n      virtual void Timeline(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::csce438::Message,::csce438::Message>* reactor) = 0;\n    };\n    typedef class async_interface experimental_async_interface;\n    virtual class async_interface* async() { return nullptr; }\n    class async_interface* experimental_async() { return async(); }\n   private:\n    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* AsyncLoginRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;\n    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;\n    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* AsyncListRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;\n    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* PrepareAsyncListRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;\n    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* AsyncFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;\n    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* PrepareAsyncFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;\n    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* AsyncUnFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;\n    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csce438::Reply>* PrepareAsyncUnFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) = 0;\n    virtual ::grpc::ClientReaderWriterInterface< ::csce438::Message, ::csce438::Message>* TimelineRaw(::grpc::ClientContext* context) = 0;\n    virtual ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>* AsyncTimelineRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;\n    virtual ::grpc::ClientAsyncReaderWriterInterface< ::csce438::Message, ::csce438::Message>* PrepareAsyncTimelineRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;\n  };\n  class Stub final : public StubInterface {\n   public:\n    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());\n    ::grpc::Status Login(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) override;\n    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> AsyncLogin(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(AsyncLoginRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(PrepareAsyncLoginRaw(context, request, cq));\n    }\n    ::grpc::Status List(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) override;\n    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> AsyncList(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(AsyncListRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> PrepareAsyncList(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(PrepareAsyncListRaw(context, request, cq));\n    }\n    ::grpc::Status Follow(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) override;\n    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> AsyncFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(AsyncFollowRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> PrepareAsyncFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(PrepareAsyncFollowRaw(context, request, cq));\n    }\n    ::grpc::Status UnFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::csce438::Reply* response) override;\n    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> AsyncUnFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(AsyncUnFollowRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>> PrepareAsyncUnFollow(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csce438::Reply>>(PrepareAsyncUnFollowRaw(context, request, cq));\n    }\n    std::unique_ptr< ::grpc::ClientReaderWriter< ::csce438::Message, ::csce438::Message>> Timeline(::grpc::ClientContext* context) {\n      return std::unique_ptr< ::grpc::ClientReaderWriter< ::csce438::Message, ::csce438::Message>>(TimelineRaw(context));\n    }\n    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>> AsyncTimeline(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {\n      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>>(AsyncTimelineRaw(context, cq, tag));\n    }\n    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>> PrepareAsyncTimeline(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {\n      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>>(PrepareAsyncTimelineRaw(context, cq));\n    }\n    class async final :\n      public StubInterface::async_interface {\n     public:\n      void Login(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) override;\n      void Login(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) override;\n      void List(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) override;\n      void List(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) override;\n      void Follow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) override;\n      void Follow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) override;\n      void UnFollow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, std::function<void(::grpc::Status)>) override;\n      void UnFollow(::grpc::ClientContext* context, const ::csce438::Request* request, ::csce438::Reply* response, ::grpc::ClientUnaryReactor* reactor) override;\n      void Timeline(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::csce438::Message,::csce438::Message>* reactor) override;\n     private:\n      friend class Stub;\n      explicit async(Stub* stub): stub_(stub) { }\n      Stub* stub() { return stub_; }\n      Stub* stub_;\n    };\n    class async* async() override { return &async_stub_; }\n\n   private:\n    std::shared_ptr< ::grpc::ChannelInterface> channel_;\n    class async async_stub_{this};\n    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* AsyncLoginRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;\n    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;\n    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* AsyncListRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;\n    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* PrepareAsyncListRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;\n    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* AsyncFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;\n    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* PrepareAsyncFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;\n    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* AsyncUnFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;\n    ::grpc::ClientAsyncResponseReader< ::csce438::Reply>* PrepareAsyncUnFollowRaw(::grpc::ClientContext* context, const ::csce438::Request& request, ::grpc::CompletionQueue* cq) override;\n    ::grpc::ClientReaderWriter< ::csce438::Message, ::csce438::Message>* TimelineRaw(::grpc::ClientContext* context) override;\n    ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>* AsyncTimelineRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;\n    ::grpc::ClientAsyncReaderWriter< ::csce438::Message, ::csce438::Message>* PrepareAsyncTimelineRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;\n    const ::grpc::internal::RpcMethod rpcmethod_Login_;\n    const ::grpc::internal::RpcMethod rpcmethod_List_;\n    const ::grpc::internal::RpcMethod rpcmethod_Follow_;\n    const ::grpc::internal::RpcMethod rpcmethod_UnFollow_;\n    const ::grpc::internal::RpcMethod rpcmethod_Timeline_;\n  };\n  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());\n\n  class Service : public ::grpc::Service {\n   public:\n    Service();\n    virtual ~Service();\n    virtual ::grpc::Status Login(::grpc::ServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response);\n    virtual ::grpc::Status List(::grpc::ServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response);\n    virtual ::grpc::Status Follow(::grpc::ServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response);\n    virtual ::grpc::Status UnFollow(::grpc::ServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response);\n    virtual ::grpc::Status Timeline(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* stream);\n  };\n  template <class BaseClass>\n  class WithAsyncMethod_Login : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithAsyncMethod_Login() {\n      ::grpc::Service::MarkMethodAsync(0);\n    }\n    ~WithAsyncMethod_Login() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestLogin(::grpc::ServerContext* context, ::csce438::Request* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithAsyncMethod_List : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithAsyncMethod_List() {\n      ::grpc::Service::MarkMethodAsync(1);\n    }\n    ~WithAsyncMethod_List() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestList(::grpc::ServerContext* context, ::csce438::Request* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithAsyncMethod_Follow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithAsyncMethod_Follow() {\n      ::grpc::Service::MarkMethodAsync(2);\n    }\n    ~WithAsyncMethod_Follow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestFollow(::grpc::ServerContext* context, ::csce438::Request* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithAsyncMethod_UnFollow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithAsyncMethod_UnFollow() {\n      ::grpc::Service::MarkMethodAsync(3);\n    }\n    ~WithAsyncMethod_UnFollow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status UnFollow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestUnFollow(::grpc::ServerContext* context, ::csce438::Request* request, ::grpc::ServerAsyncResponseWriter< ::csce438::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithAsyncMethod_Timeline : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithAsyncMethod_Timeline() {\n      ::grpc::Service::MarkMethodAsync(4);\n    }\n    ~WithAsyncMethod_Timeline() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestTimeline(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::csce438::Message, ::csce438::Message>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncBidiStreaming(4, context, stream, new_call_cq, notification_cq, tag);\n    }\n  };\n  typedef WithAsyncMethod_Login<WithAsyncMethod_List<WithAsyncMethod_Follow<WithAsyncMethod_UnFollow<WithAsyncMethod_Timeline<Service > > > > > AsyncService;\n  template <class BaseClass>\n  class WithCallbackMethod_Login : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithCallbackMethod_Login() {\n      ::grpc::Service::MarkMethodCallback(0,\n          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>(\n            [this](\n                   ::grpc::CallbackServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response) { return this->Login(context, request, response); }));}\n    void SetMessageAllocatorFor_Login(\n        ::grpc::MessageAllocator< ::csce438::Request, ::csce438::Reply>* allocator) {\n      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);\n      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>*>(handler)\n              ->SetMessageAllocator(allocator);\n    }\n    ~WithCallbackMethod_Login() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerUnaryReactor* Login(\n      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/)  { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithCallbackMethod_List : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithCallbackMethod_List() {\n      ::grpc::Service::MarkMethodCallback(1,\n          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>(\n            [this](\n                   ::grpc::CallbackServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response) { return this->List(context, request, response); }));}\n    void SetMessageAllocatorFor_List(\n        ::grpc::MessageAllocator< ::csce438::Request, ::csce438::Reply>* allocator) {\n      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);\n      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>*>(handler)\n              ->SetMessageAllocator(allocator);\n    }\n    ~WithCallbackMethod_List() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerUnaryReactor* List(\n      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/)  { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithCallbackMethod_Follow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithCallbackMethod_Follow() {\n      ::grpc::Service::MarkMethodCallback(2,\n          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>(\n            [this](\n                   ::grpc::CallbackServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response) { return this->Follow(context, request, response); }));}\n    void SetMessageAllocatorFor_Follow(\n        ::grpc::MessageAllocator< ::csce438::Request, ::csce438::Reply>* allocator) {\n      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);\n      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>*>(handler)\n              ->SetMessageAllocator(allocator);\n    }\n    ~WithCallbackMethod_Follow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerUnaryReactor* Follow(\n      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/)  { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithCallbackMethod_UnFollow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithCallbackMethod_UnFollow() {\n      ::grpc::Service::MarkMethodCallback(3,\n          new ::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>(\n            [this](\n                   ::grpc::CallbackServerContext* context, const ::csce438::Request* request, ::csce438::Reply* response) { return this->UnFollow(context, request, response); }));}\n    void SetMessageAllocatorFor_UnFollow(\n        ::grpc::MessageAllocator< ::csce438::Request, ::csce438::Reply>* allocator) {\n      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);\n      static_cast<::grpc::internal::CallbackUnaryHandler< ::csce438::Request, ::csce438::Reply>*>(handler)\n              ->SetMessageAllocator(allocator);\n    }\n    ~WithCallbackMethod_UnFollow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status UnFollow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerUnaryReactor* UnFollow(\n      ::grpc::CallbackServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/)  { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithCallbackMethod_Timeline : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithCallbackMethod_Timeline() {\n      ::grpc::Service::MarkMethodCallback(4,\n          new ::grpc::internal::CallbackBidiHandler< ::csce438::Message, ::csce438::Message>(\n            [this](\n                   ::grpc::CallbackServerContext* context) { return this->Timeline(context); }));\n    }\n    ~WithCallbackMethod_Timeline() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerBidiReactor< ::csce438::Message, ::csce438::Message>* Timeline(\n      ::grpc::CallbackServerContext* /*context*/)\n      { return nullptr; }\n  };\n  typedef WithCallbackMethod_Login<WithCallbackMethod_List<WithCallbackMethod_Follow<WithCallbackMethod_UnFollow<WithCallbackMethod_Timeline<Service > > > > > CallbackService;\n  typedef CallbackService ExperimentalCallbackService;\n  template <class BaseClass>\n  class WithGenericMethod_Login : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithGenericMethod_Login() {\n      ::grpc::Service::MarkMethodGeneric(0);\n    }\n    ~WithGenericMethod_Login() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n  };\n  template <class BaseClass>\n  class WithGenericMethod_List : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithGenericMethod_List() {\n      ::grpc::Service::MarkMethodGeneric(1);\n    }\n    ~WithGenericMethod_List() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n  };\n  template <class BaseClass>\n  class WithGenericMethod_Follow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithGenericMethod_Follow() {\n      ::grpc::Service::MarkMethodGeneric(2);\n    }\n    ~WithGenericMethod_Follow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n  };\n  template <class BaseClass>\n  class WithGenericMethod_UnFollow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithGenericMethod_UnFollow() {\n      ::grpc::Service::MarkMethodGeneric(3);\n    }\n    ~WithGenericMethod_UnFollow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status UnFollow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n  };\n  template <class BaseClass>\n  class WithGenericMethod_Timeline : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithGenericMethod_Timeline() {\n      ::grpc::Service::MarkMethodGeneric(4);\n    }\n    ~WithGenericMethod_Timeline() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n  };\n  template <class BaseClass>\n  class WithRawMethod_Login : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawMethod_Login() {\n      ::grpc::Service::MarkMethodRaw(0);\n    }\n    ~WithRawMethod_Login() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithRawMethod_List : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawMethod_List() {\n      ::grpc::Service::MarkMethodRaw(1);\n    }\n    ~WithRawMethod_List() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithRawMethod_Follow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawMethod_Follow() {\n      ::grpc::Service::MarkMethodRaw(2);\n    }\n    ~WithRawMethod_Follow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestFollow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithRawMethod_UnFollow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawMethod_UnFollow() {\n      ::grpc::Service::MarkMethodRaw(3);\n    }\n    ~WithRawMethod_UnFollow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status UnFollow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestUnFollow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithRawMethod_Timeline : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawMethod_Timeline() {\n      ::grpc::Service::MarkMethodRaw(4);\n    }\n    ~WithRawMethod_Timeline() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    void RequestTimeline(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {\n      ::grpc::Service::RequestAsyncBidiStreaming(4, context, stream, new_call_cq, notification_cq, tag);\n    }\n  };\n  template <class BaseClass>\n  class WithRawCallbackMethod_Login : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawCallbackMethod_Login() {\n      ::grpc::Service::MarkMethodRawCallback(0,\n          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(\n            [this](\n                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Login(context, request, response); }));\n    }\n    ~WithRawCallbackMethod_Login() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerUnaryReactor* Login(\n      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithRawCallbackMethod_List : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawCallbackMethod_List() {\n      ::grpc::Service::MarkMethodRawCallback(1,\n          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(\n            [this](\n                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->List(context, request, response); }));\n    }\n    ~WithRawCallbackMethod_List() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerUnaryReactor* List(\n      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithRawCallbackMethod_Follow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawCallbackMethod_Follow() {\n      ::grpc::Service::MarkMethodRawCallback(2,\n          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(\n            [this](\n                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Follow(context, request, response); }));\n    }\n    ~WithRawCallbackMethod_Follow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerUnaryReactor* Follow(\n      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithRawCallbackMethod_UnFollow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawCallbackMethod_UnFollow() {\n      ::grpc::Service::MarkMethodRawCallback(3,\n          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(\n            [this](\n                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnFollow(context, request, response); }));\n    }\n    ~WithRawCallbackMethod_UnFollow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status UnFollow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerUnaryReactor* UnFollow(\n      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithRawCallbackMethod_Timeline : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithRawCallbackMethod_Timeline() {\n      ::grpc::Service::MarkMethodRawCallback(4,\n          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(\n            [this](\n                   ::grpc::CallbackServerContext* context) { return this->Timeline(context); }));\n    }\n    ~WithRawCallbackMethod_Timeline() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable synchronous version of this method\n    ::grpc::Status Timeline(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::csce438::Message, ::csce438::Message>* /*stream*/)  override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Timeline(\n      ::grpc::CallbackServerContext* /*context*/)\n      { return nullptr; }\n  };\n  template <class BaseClass>\n  class WithStreamedUnaryMethod_Login : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithStreamedUnaryMethod_Login() {\n      ::grpc::Service::MarkMethodStreamed(0,\n        new ::grpc::internal::StreamedUnaryHandler<\n          ::csce438::Request, ::csce438::Reply>(\n            [this](::grpc::ServerContext* context,\n                   ::grpc::ServerUnaryStreamer<\n                     ::csce438::Request, ::csce438::Reply>* streamer) {\n                       return this->StreamedLogin(context,\n                         streamer);\n                  }));\n    }\n    ~WithStreamedUnaryMethod_Login() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable regular version of this method\n    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    // replace default version of method with streamed unary\n    virtual ::grpc::Status StreamedLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Request,::csce438::Reply>* server_unary_streamer) = 0;\n  };\n  template <class BaseClass>\n  class WithStreamedUnaryMethod_List : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithStreamedUnaryMethod_List() {\n      ::grpc::Service::MarkMethodStreamed(1,\n        new ::grpc::internal::StreamedUnaryHandler<\n          ::csce438::Request, ::csce438::Reply>(\n            [this](::grpc::ServerContext* context,\n                   ::grpc::ServerUnaryStreamer<\n                     ::csce438::Request, ::csce438::Reply>* streamer) {\n                       return this->StreamedList(context,\n                         streamer);\n                  }));\n    }\n    ~WithStreamedUnaryMethod_List() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable regular version of this method\n    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    // replace default version of method with streamed unary\n    virtual ::grpc::Status StreamedList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Request,::csce438::Reply>* server_unary_streamer) = 0;\n  };\n  template <class BaseClass>\n  class WithStreamedUnaryMethod_Follow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithStreamedUnaryMethod_Follow() {\n      ::grpc::Service::MarkMethodStreamed(2,\n        new ::grpc::internal::StreamedUnaryHandler<\n          ::csce438::Request, ::csce438::Reply>(\n            [this](::grpc::ServerContext* context,\n                   ::grpc::ServerUnaryStreamer<\n                     ::csce438::Request, ::csce438::Reply>* streamer) {\n                       return this->StreamedFollow(context,\n                         streamer);\n                  }));\n    }\n    ~WithStreamedUnaryMethod_Follow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable regular version of this method\n    ::grpc::Status Follow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    // replace default version of method with streamed unary\n    virtual ::grpc::Status StreamedFollow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Request,::csce438::Reply>* server_unary_streamer) = 0;\n  };\n  template <class BaseClass>\n  class WithStreamedUnaryMethod_UnFollow : public BaseClass {\n   private:\n    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}\n   public:\n    WithStreamedUnaryMethod_UnFollow() {\n      ::grpc::Service::MarkMethodStreamed(3,\n        new ::grpc::internal::StreamedUnaryHandler<\n          ::csce438::Request, ::csce438::Reply>(\n            [this](::grpc::ServerContext* context,\n                   ::grpc::ServerUnaryStreamer<\n                     ::csce438::Request, ::csce438::Reply>* streamer) {\n                       return this->StreamedUnFollow(context,\n                         streamer);\n                  }));\n    }\n    ~WithStreamedUnaryMethod_UnFollow() override {\n      BaseClassMustBeDerivedFromService(this);\n    }\n    // disable regular version of this method\n    ::grpc::Status UnFollow(::grpc::ServerContext* /*context*/, const ::csce438::Request* /*request*/, ::csce438::Reply* /*response*/) override {\n      abort();\n      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n    }\n    // replace default version of method with streamed unary\n    virtual ::grpc::Status StreamedUnFollow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csce438::Request,::csce438::Reply>* server_unary_streamer) = 0;\n  };\n  typedef WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_List<WithStreamedUnaryMethod_Follow<WithStreamedUnaryMethod_UnFollow<Service > > > > StreamedUnaryService;\n  typedef Service SplitStreamedService;\n  typedef WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_List<WithStreamedUnaryMethod_Follow<WithStreamedUnaryMethod_UnFollow<Service > > > > StreamedService;\n};\n\n}  // namespace csce438\n\n\n#endif  // GRPC_sns_2eproto__INCLUDED\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":7214,"scrollleft":0,"selection":{"start":{"row":536,"column":5},"end":{"row":536,"column":5},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":253,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1646078724020}