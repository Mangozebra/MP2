{"filter":false,"title":"client.h","tooltip":"/client.h","undoManager":{"mark":3,"position":3,"stack":[[{"start":{"row":0,"column":0},"end":{"row":200,"column":0},"action":"remove","lines":["#include <iostream>","#include <string>","#include <ctime>","#include <vector>","#include <grpc++/grpc++.h>","","#define MAX_DATA 256","","enum IStatus","{","    SUCCESS,","    FAILURE_ALREADY_EXISTS,","    FAILURE_NOT_EXISTS,","    FAILURE_INVALID_USERNAME,","    FAILURE_INVALID,","    FAILURE_UNKNOWN","};","","/*"," * IReply structure is designed to be used for displaying the"," * result of the command that has been sent to the server."," * For example, in the \"processCommand\" function, you should"," * declare a variable of IReply structure and set based on"," * the type of command and the result."," *"," * - FOLLOW/UNFOLLOW/TIMELINE command:"," * IReply ireply;"," * ireply.grpc_status = return value of a service method"," * ireply.comm_status = one of values in IStatus enum"," *"," * - LIST command:"," * IReply ireply;"," * ireply.grpc_status = return value of a service method"," * ireply.comm_status = one of values in IStatus enum"," * reply.users = list of all users who connected to the server at least onece"," * reply.following_users = list of users who current who current user are following;"," *"," * This structure is not for communicating between server and client."," * You need to design your own rules for the communication."," */","struct IReply","{","    grpc::Status grpc_status;","    enum IStatus comm_status;","    std::vector<std::string> all_users;","    std::vector<std::string> following_users;","};","","class IClient","{","    public:","        void run_client() { run(); }","","    protected:","        /*","         * Pure virtual functions to be implemented by students","         */","        virtual int connectTo() = 0;","        virtual IReply processCommand(std::string& cmd) = 0;","        virtual void processTimeline() = 0;","","    private:","","        void run();","","        void displayTitle() const;","        std::string getCommand() const;","        void displayCommandReply(const std::string& comm, const IReply& reply) const;","        void toUpperCase(std::string& str) const;","};","","void IClient::run()","{","    int ret = connectTo();","    if (ret < 0) {","        std::cout << \"connection failed: \" << ret << std::endl;","        exit(1);","    }","    displayTitle();","    while (1) {","        std::string cmd = getCommand();","        IReply reply = processCommand(cmd);","        displayCommandReply(cmd, reply);","        if (reply.grpc_status.ok() && reply.comm_status == SUCCESS","                && cmd == \"TIMELINE\") {","            std::cout << \"Now you are in the timeline\" << std::endl;","            processTimeline();","        }","    }","}","","void IClient::displayTitle() const","{","    std::cout << \"\\n========= TINY SNS CLIENT =========\\n\";","    std::cout << \" Command Lists and Format:\\n\";","    std::cout << \" FOLLOW <username>\\n\";","    std::cout << \" UNFOLLOW <username>\\n\";","    std::cout << \" LIST\\n\";","    std::cout << \" TIMELINE\\n\";","    std::cout << \"=====================================\\n\";","}","","std::string IClient::getCommand() const","{","\tstd::string input;","\twhile (1) {","\t\tstd::cout << \"Cmd> \";","\t\tstd::getline(std::cin, input);","\t\tstd::size_t index = input.find_first_of(\" \");","\t\tif (index != std::string::npos) {","\t\t\tstd::string cmd = input.substr(0, index);","\t\t\ttoUpperCase(cmd);","\t\t\tif(input.length() == index+1){","\t\t\t\tstd::cout << \"Invalid Input -- No Arguments Given\\n\";","\t\t\t\tcontinue;","\t\t\t}","\t\t\tstd::string argument = input.substr(index+1, (input.length()-index));","\t\t\tinput = cmd + \" \" + argument;","\t\t} else {","\t\t\ttoUpperCase(input);","\t\t\tif (input != \"LIST\" && input != \"TIMELINE\") {","\t\t\t\tstd::cout << \"Invalid Command\\n\";","\t\t\t\tcontinue;","\t\t\t}","\t\t}","\t\tbreak;","\t}","\treturn input;","}","","void IClient::displayCommandReply(const std::string& comm, const IReply& reply) const","{","\tif (reply.grpc_status.ok()) {","\t\tswitch (reply.comm_status) {","\t\t\tcase SUCCESS:","                std::cout << \"Command completed successfully\\n\";","\t\t\t\tif (comm == \"LIST\") {","\t\t\t\t\tstd::cout << \"All users: \";","                    for (std::string room : reply.all_users) {","                        std::cout << room << \", \";","                    }","\t\t\t\t\tstd::cout << \"\\nFollowing users: \";","                    for (std::string room : reply.following_users) {","                        std::cout << room << \", \";","                    }","                    std::cout << std::endl;","\t\t\t\t}","\t\t\t\tbreak;","\t\t\tcase FAILURE_ALREADY_EXISTS:","                std::cout << \"Input username already exists, command failed\\n\";","\t\t\t\tbreak;","\t\t\tcase FAILURE_NOT_EXISTS:","                std::cout << \"Input username does not exists, command failed\\n\";","\t\t\t\tbreak;","\t\t\tcase FAILURE_INVALID_USERNAME:","                std::cout << \"Command failed with invalid username\\n\";","\t\t\t\tbreak;","\t\t\tcase FAILURE_INVALID:","                std::cout << \"Command failed with invalid command\\n\";","\t\t\t\tbreak;","\t\t\tcase FAILURE_UNKNOWN:","                std::cout << \"Command failed with unknown reason\\n\";","\t\t\t\tbreak;","\t\t\tdefault:","                std::cout << \"Invalid status\\n\";","\t\t\t\tbreak;","\t\t}","\t} else {","\t\tstd::cout << \"grpc failed: \" << reply.grpc_status.error_message() << std::endl;","\t}","}","","void IClient::toUpperCase(std::string& str) const","{","    std::locale loc;","    for (std::string::size_type i = 0; i < str.size(); i++)","        str[i] = toupper(str[i], loc);","}","","/*"," * get/displayPostMessage functions will be called in chatmode"," */","std::string getPostMessage()","{","    char buf[MAX_DATA];","    while (1) {","\t    fgets(buf, MAX_DATA, stdin);","\t    if (buf[0] != '\\n')  break;","    }","","    std::string message(buf);","    return message;","}","","void displayPostMessage(const std::string& sender, const std::string& message, std::time_t& time)","{","    std::string t_str(std::ctime(&time));","    t_str[t_str.size()-1] = '\\0';","    std::cout << sender << \"(\" << t_str << \") >> \" << message << std::endl;","}",""],"id":1},{"start":{"row":0,"column":0},"end":{"row":200,"column":0},"action":"insert","lines":["#include <iostream>","#include <string>","#include <ctime>","#include <vector>","#include <grpc++/grpc++.h>","","#define MAX_DATA 256","","enum IStatus","{","    SUCCESS,","    FAILURE_ALREADY_EXISTS,","    FAILURE_NOT_EXISTS,","    FAILURE_INVALID_USERNAME,","    FAILURE_INVALID,","    FAILURE_UNKNOWN","};","","/*"," * IReply structure is designed to be used for displaying the"," * result of the command that has been sent to the server."," * For example, in the \"processCommand\" function, you should"," * declare a variable of IReply structure and set based on"," * the type of command and the result."," *"," * - FOLLOW/UNFOLLOW/TIMELINE command:"," * IReply ireply;"," * ireply.grpc_status = return value of a service method"," * ireply.comm_status = one of values in IStatus enum"," *"," * - LIST command:"," * IReply ireply;"," * ireply.grpc_status = return value of a service method"," * ireply.comm_status = one of values in IStatus enum"," * reply.users = list of all users who connected to the server at least onece"," * reply.following_users = list of users who current who current user are following;"," *"," * This structure is not for communicating between server and client."," * You need to design your own rules for the communication."," */","struct IReply","{","    grpc::Status grpc_status;","    enum IStatus comm_status;","    std::vector<std::string> all_users;","    std::vector<std::string> following_users;","};","","class IClient","{","    public:","        void run_client() { run(); }","","    protected:","        /*","         * Pure virtual functions to be implemented by students","         */","        virtual int connectTo() = 0;","        virtual IReply processCommand(std::string& cmd) = 0;","        virtual void processTimeline() = 0;","","    private:","","        void run();","","        void displayTitle() const;","        std::string getCommand() const;","        void displayCommandReply(const std::string& comm, const IReply& reply) const;","        void toUpperCase(std::string& str) const;","};","","void IClient::run()","{","    int ret = connectTo();","    if (ret < 0) {","        std::cout << \"connection failed: \" << ret << std::endl;","        exit(1);","    }","    displayTitle();","    while (1) {","        std::string cmd = getCommand();","        IReply reply = processCommand(cmd);","        displayCommandReply(cmd, reply);","        if (reply.grpc_status.ok() && reply.comm_status == SUCCESS","                && cmd == \"TIMELINE\") {","            std::cout << \"Now you are in the timeline\" << std::endl;","            processTimeline();","        }","    }","}","","void IClient::displayTitle() const","{","    std::cout << \"\\n========= TINY SNS CLIENT =========\\n\";","    std::cout << \" Command Lists and Format:\\n\";","    std::cout << \" FOLLOW <username>\\n\";","    std::cout << \" UNFOLLOW <username>\\n\";","    std::cout << \" LIST\\n\";","    std::cout << \" TIMELINE\\n\";","    std::cout << \"=====================================\\n\";","}","","std::string IClient::getCommand() const","{","\tstd::string input;","\twhile (1) {","\t\tstd::cout << \"Cmd> \";","\t\tstd::getline(std::cin, input);","\t\tstd::size_t index = input.find_first_of(\" \");","\t\tif (index != std::string::npos) {","\t\t\tstd::string cmd = input.substr(0, index);","\t\t\ttoUpperCase(cmd);","\t\t\tif(input.length() == index+1){","\t\t\t\tstd::cout << \"Invalid Input -- No Arguments Given\\n\";","\t\t\t\tcontinue;","\t\t\t}","\t\t\tstd::string argument = input.substr(index+1, (input.length()-index));","\t\t\tinput = cmd + \" \" + argument;","\t\t} else {","\t\t\ttoUpperCase(input);","\t\t\tif (input != \"LIST\" && input != \"TIMELINE\") {","\t\t\t\tstd::cout << \"Invalid Command\\n\";","\t\t\t\tcontinue;","\t\t\t}","\t\t}","\t\tbreak;","\t}","\treturn input;","}","","void IClient::displayCommandReply(const std::string& comm, const IReply& reply) const","{","\tif (reply.grpc_status.ok()) {","\t\tswitch (reply.comm_status) {","\t\t\tcase SUCCESS:","                std::cout << \"Command completed successfully\\n\";","\t\t\t\tif (comm == \"LIST\") {","\t\t\t\t\tstd::cout << \"All users: \";","                    for (std::string room : reply.all_users) {","                        std::cout << room << \", \";","                    }","\t\t\t\t\tstd::cout << \"\\nFollowers: \";","                    for (std::string room : reply.following_users) {","                        std::cout << room << \", \";","                    }","                    std::cout << std::endl;","\t\t\t\t}","\t\t\t\tbreak;","\t\t\tcase FAILURE_ALREADY_EXISTS:","                std::cout << \"Input username already exists, command failed\\n\";","\t\t\t\tbreak;","\t\t\tcase FAILURE_NOT_EXISTS:","                std::cout << \"Input username does not exists, command failed\\n\";","\t\t\t\tbreak;","\t\t\tcase FAILURE_INVALID_USERNAME:","                std::cout << \"Command failed with invalid username\\n\";","\t\t\t\tbreak;","\t\t\tcase FAILURE_INVALID:","                std::cout << \"Command failed with invalid command\\n\";","\t\t\t\tbreak;","\t\t\tcase FAILURE_UNKNOWN:","                std::cout << \"Command failed with unknown reason\\n\";","\t\t\t\tbreak;","\t\t\tdefault:","                std::cout << \"Invalid status\\n\";","\t\t\t\tbreak;","\t\t}","\t} else {","\t\tstd::cout << \"grpc failed: \" << reply.grpc_status.error_message() << std::endl;","\t}","}","","void IClient::toUpperCase(std::string& str) const","{","    std::locale loc;","    for (std::string::size_type i = 0; i < str.size(); i++)","        str[i] = toupper(str[i], loc);","}","","/*"," * get/displayPostMessage functions will be called in chatmode"," */","std::string getPostMessage()","{","    char buf[MAX_DATA];","    while (1) {","\t    fgets(buf, MAX_DATA, stdin);","\t    if (buf[0] != '\\n')  break;","    }","","    std::string message(buf);","    return message;","}","","void displayPostMessage(const std::string& sender, const std::string& message, std::time_t& time)","{","    std::string t_str(std::ctime(&time));","    t_str[t_str.size()-1] = '\\0';","    std::cout << sender << \"(\" << t_str << \") >> \" << message << std::endl;","}",""]}],[{"start":{"row":194,"column":79},"end":{"row":194,"column":80},"action":"insert","lines":["c"],"id":2},{"start":{"row":194,"column":80},"end":{"row":194,"column":81},"action":"insert","lines":["o"]},{"start":{"row":194,"column":81},"end":{"row":194,"column":82},"action":"insert","lines":["n"]},{"start":{"row":194,"column":82},"end":{"row":194,"column":83},"action":"insert","lines":["s"]},{"start":{"row":194,"column":83},"end":{"row":194,"column":84},"action":"insert","lines":["t"]}],[{"start":{"row":194,"column":84},"end":{"row":194,"column":85},"action":"insert","lines":[" "],"id":3}],[{"start":{"row":198,"column":70},"end":{"row":198,"column":74},"action":"remove","lines":["endl"],"id":55},{"start":{"row":198,"column":69},"end":{"row":198,"column":70},"action":"remove","lines":[":"]},{"start":{"row":198,"column":68},"end":{"row":198,"column":69},"action":"remove","lines":[":"]},{"start":{"row":198,"column":67},"end":{"row":198,"column":68},"action":"remove","lines":["d"]},{"start":{"row":198,"column":66},"end":{"row":198,"column":67},"action":"remove","lines":["t"]},{"start":{"row":198,"column":65},"end":{"row":198,"column":66},"action":"remove","lines":["s"]},{"start":{"row":198,"column":64},"end":{"row":198,"column":65},"action":"remove","lines":[" "]},{"start":{"row":198,"column":63},"end":{"row":198,"column":64},"action":"remove","lines":["<"]},{"start":{"row":198,"column":62},"end":{"row":198,"column":63},"action":"remove","lines":["<"]},{"start":{"row":198,"column":61},"end":{"row":198,"column":62},"action":"remove","lines":[" "]}]]},"ace":{"folds":[],"scrolltop":2194,"scrollleft":0,"selection":{"start":{"row":198,"column":61},"end":{"row":198,"column":61},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":165,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1646281070020,"hash":"1d9c68e18504c1d4ea7c6df799c11ad9b938cca6"}